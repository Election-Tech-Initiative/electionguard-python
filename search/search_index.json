{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"\ud83d\uddf3 ElectionGuard Python This repository is a \"reference implementation\" of ElectionGuard written in Python 3. This implementation can be used to conduct End-to-End Verifiable Elections as well as privacy-enhanced risk-limiting audits. Components of this library can also be used to construct \"Verifiers\" to validate the results of an ElectionGuard election. \ud83d\udcc1 In This Repository File/folder Description docs Documentation for using the library src/electionguard Source code to the ElectionGuard library src/electionguardtest sample data and generators for testing stubs Type annotations for external libraries tests Tests to exercise this codebase CONTRIBUTING.md Guidelines for contributing README.md This README file LICENSE The license for ElectionGuard-Python. \u2753 What Is ElectionGuard? ElectionGuard is an open source software development kit (SDK) that makes voting more secure, transparent and accessible. The ElectionGuard SDK leverages homomorphic encryption to ensure that votes recorded by electronic systems of any type remain encrypted, secure, and secret. Meanwhile, ElectionGuard also allows verifiable and accurate tallying of ballots by any 3rd party organization without compromising secrecy or security. Learn More in the ElectionGuard Repository \ud83e\uddb8 How Can I use ElectionGuard? ElectionGuard supports a variety of use cases. The Primary use case is to generate verifiable end-to-end (E2E) encrypted elections. The Electionguard process can also be used for other use cases such as privacy enhanced risk-limiting audits (RLAs). \ud83d\udcbb Requirements Python 3.8 is required to develop this SDK. If developer uses multiple versions of python, pyenv is suggested to assist version management. GNU Make is used to simplify the commands and GitHub Actions. This approach is recommended to simplify the command line experience. This is built in for MacOS and Linux. For Windows, setup is simpler with Chocolatey and installing the provided make package . The other Windows option is manually installing make . Gmpy2 is used for Arbitrary-precision arithmetic which has its own installation requirements (native C libraries) on Linux and MacOS. \u26a0\ufe0f Note: This is not required for Windows since the gmpy2 precompiled libraries are provided. pipenv is used to configure the python environment. Installation instructions can be found here . \ud83d\ude80 Quick Start Using make , the entire GitHub Action workflow can be run with one command: make The unit and integration tests can also be run with make: make test A complete end-to-end election example can be run independently by executing: make test-example For more detailed build and run options, see the documentation . \ud83d\udcc4 Documentation Sections: Design and Architecture Build and Run Project Workflow Election Manifest Step-by-Step Process: Configure Election Key Ceremony Encrypt Ballots Cast and Spoil Decrypt Tally Publish and Verify \u2753Questions Electionguard would love for you to ask questions out in the open using GitHub Issues. If you really want to email the ElectionGuard team, reach out at electionguard@microsoft.com.","title":"Home"},{"location":"#electionguard-python","text":"This repository is a \"reference implementation\" of ElectionGuard written in Python 3. This implementation can be used to conduct End-to-End Verifiable Elections as well as privacy-enhanced risk-limiting audits. Components of this library can also be used to construct \"Verifiers\" to validate the results of an ElectionGuard election.","title":"\ud83d\uddf3 ElectionGuard Python"},{"location":"#in-this-repository","text":"File/folder Description docs Documentation for using the library src/electionguard Source code to the ElectionGuard library src/electionguardtest sample data and generators for testing stubs Type annotations for external libraries tests Tests to exercise this codebase CONTRIBUTING.md Guidelines for contributing README.md This README file LICENSE The license for ElectionGuard-Python.","title":"\ud83d\udcc1 In This Repository"},{"location":"#what-is-electionguard","text":"ElectionGuard is an open source software development kit (SDK) that makes voting more secure, transparent and accessible. The ElectionGuard SDK leverages homomorphic encryption to ensure that votes recorded by electronic systems of any type remain encrypted, secure, and secret. Meanwhile, ElectionGuard also allows verifiable and accurate tallying of ballots by any 3rd party organization without compromising secrecy or security. Learn More in the ElectionGuard Repository","title":"\u2753 What Is ElectionGuard?"},{"location":"#how-can-i-use-electionguard","text":"ElectionGuard supports a variety of use cases. The Primary use case is to generate verifiable end-to-end (E2E) encrypted elections. The Electionguard process can also be used for other use cases such as privacy enhanced risk-limiting audits (RLAs).","title":"\ud83e\uddb8 How Can I use ElectionGuard?"},{"location":"#requirements","text":"Python 3.8 is required to develop this SDK. If developer uses multiple versions of python, pyenv is suggested to assist version management. GNU Make is used to simplify the commands and GitHub Actions. This approach is recommended to simplify the command line experience. This is built in for MacOS and Linux. For Windows, setup is simpler with Chocolatey and installing the provided make package . The other Windows option is manually installing make . Gmpy2 is used for Arbitrary-precision arithmetic which has its own installation requirements (native C libraries) on Linux and MacOS. \u26a0\ufe0f Note: This is not required for Windows since the gmpy2 precompiled libraries are provided. pipenv is used to configure the python environment. Installation instructions can be found here .","title":"\ud83d\udcbb Requirements"},{"location":"#quick-start","text":"Using make , the entire GitHub Action workflow can be run with one command: make The unit and integration tests can also be run with make: make test A complete end-to-end election example can be run independently by executing: make test-example For more detailed build and run options, see the documentation .","title":"\ud83d\ude80 Quick Start"},{"location":"#documentation","text":"Sections: Design and Architecture Build and Run Project Workflow Election Manifest Step-by-Step Process: Configure Election Key Ceremony Encrypt Ballots Cast and Spoil Decrypt Tally Publish and Verify","title":"\ud83d\udcc4 Documentation"},{"location":"#questions","text":"Electionguard would love for you to ask questions out in the open using GitHub Issues. If you really want to email the ElectionGuard team, reach out at electionguard@microsoft.com.","title":"\u2753Questions"},{"location":"0_Configure_Election/","text":"Election Configuration An election in ElectionGuard is defined as a set of metadata and cryptographic artifacts necessary to encrypt, conduct, tally, decrypt, and verify an election. The Data format used for election metadata is based on the NIST Election Common Standard Data Specification but includes some modifications to support the end-to-end cryptography of ElectionGuard. Election metadata is described in a specific format parseable into an Manifest and it's validity is checked to ensure that it is of an appropriate structure to conduct an End-to-End Verified ElectionGuard Election. ElectionGuard only verifies the components of the election metadata that are necessary to encrypt and decrypt the election. Some components of the election metadata are not checked for structural validity, but are used when generating a hash representation of the Manifest . From an Manifest we derive an InternalManifest that includes a subset of the elements from the Manifest required to verify ballots are correct. Additionally a CiphertextElectionContext is created during the Key Ceremony that includes the cryptographic artifacts necessary for encrypting ballots. Glossary Election Manifest The election metadata in json format that is parsed into an Election Description Election Description The election metadata that describes the structure and type of the election, including geopolitical units, contests, candidates, and ballot styles, etc. Internal Election Description The subset of the Manifest required by ElectionGuard to validate ballots are correctly associated with an election. This component mutates the state of the Election Description. Ciphertext Election Context The cryptographic context of an election that is configured during the Key Ceremony Description Hash a Hash representation of the original Manifest. Process Define an election according to the Manifest requirements. Use the NIST Common Standard Data Specification as a guide, but note the differences in election.py and the provided sample manifest . Parse the Manifest into the application. Define the encryption parameters necessary for conducting an election (see Key Ceremony ). Create the Pubic Key either from a single secret, or from the Key Ceremony. Build the InternalManifest and CiphertextElectionContext from the Manifest and ElGamalKeyPair.public_key . Usage Example import os from electionguard.election import CiphertextElectionContext from electionguard.election_builder import ElectionBuilder from electionguard.elgamal import ElGamalKeyPair, elgamal_keypair_from_secret from electionguard.manifest import Manifest, InternalManifest # Open an election manifest file with open(os.path.join(some_path, \"election-manifest.json\"), \"r\") as manifest: string_representation = manifest.read() election_description = Manifest.from_json(string_representation) # Create an election builder instance, and configure it for a single public-private keypair. # in a real election, you would configure this for a group of guardians. See Key Ceremony for more information. builder = ElectionBuilder( number_of_guardians=1, # since we will generate a single public-private keypair, we set this to 1 quorum=1, # since we will generate a single public-private keypair, we set this to 1 description=election_description ) # Generate an ElGamal Keypair from a secret. In a real election you would use the Key Ceremony instead. some_secret_value: int = 12345 keypair: ElGamalKeyPair = elgamal_keypair_from_secret(some_secret_value) builder.set_public_key(keypair.public_key) # get an `InternalElectionDescription` and `CiphertextElectionContext` # that are used for the remainder of the election. (internal_manifest, context) = builder.build()","title":"0. Configure Election"},{"location":"0_Configure_Election/#election-configuration","text":"An election in ElectionGuard is defined as a set of metadata and cryptographic artifacts necessary to encrypt, conduct, tally, decrypt, and verify an election. The Data format used for election metadata is based on the NIST Election Common Standard Data Specification but includes some modifications to support the end-to-end cryptography of ElectionGuard. Election metadata is described in a specific format parseable into an Manifest and it's validity is checked to ensure that it is of an appropriate structure to conduct an End-to-End Verified ElectionGuard Election. ElectionGuard only verifies the components of the election metadata that are necessary to encrypt and decrypt the election. Some components of the election metadata are not checked for structural validity, but are used when generating a hash representation of the Manifest . From an Manifest we derive an InternalManifest that includes a subset of the elements from the Manifest required to verify ballots are correct. Additionally a CiphertextElectionContext is created during the Key Ceremony that includes the cryptographic artifacts necessary for encrypting ballots.","title":"Election Configuration"},{"location":"0_Configure_Election/#glossary","text":"Election Manifest The election metadata in json format that is parsed into an Election Description Election Description The election metadata that describes the structure and type of the election, including geopolitical units, contests, candidates, and ballot styles, etc. Internal Election Description The subset of the Manifest required by ElectionGuard to validate ballots are correctly associated with an election. This component mutates the state of the Election Description. Ciphertext Election Context The cryptographic context of an election that is configured during the Key Ceremony Description Hash a Hash representation of the original Manifest.","title":"Glossary"},{"location":"0_Configure_Election/#process","text":"Define an election according to the Manifest requirements. Use the NIST Common Standard Data Specification as a guide, but note the differences in election.py and the provided sample manifest . Parse the Manifest into the application. Define the encryption parameters necessary for conducting an election (see Key Ceremony ). Create the Pubic Key either from a single secret, or from the Key Ceremony. Build the InternalManifest and CiphertextElectionContext from the Manifest and ElGamalKeyPair.public_key .","title":"Process"},{"location":"0_Configure_Election/#usage-example","text":"import os from electionguard.election import CiphertextElectionContext from electionguard.election_builder import ElectionBuilder from electionguard.elgamal import ElGamalKeyPair, elgamal_keypair_from_secret from electionguard.manifest import Manifest, InternalManifest # Open an election manifest file with open(os.path.join(some_path, \"election-manifest.json\"), \"r\") as manifest: string_representation = manifest.read() election_description = Manifest.from_json(string_representation) # Create an election builder instance, and configure it for a single public-private keypair. # in a real election, you would configure this for a group of guardians. See Key Ceremony for more information. builder = ElectionBuilder( number_of_guardians=1, # since we will generate a single public-private keypair, we set this to 1 quorum=1, # since we will generate a single public-private keypair, we set this to 1 description=election_description ) # Generate an ElGamal Keypair from a secret. In a real election you would use the Key Ceremony instead. some_secret_value: int = 12345 keypair: ElGamalKeyPair = elgamal_keypair_from_secret(some_secret_value) builder.set_public_key(keypair.public_key) # get an `InternalElectionDescription` and `CiphertextElectionContext` # that are used for the remainder of the election. (internal_manifest, context) = builder.build()","title":"Usage Example"},{"location":"1_Key_Ceremony/","text":"Key Ceremony The ElectionGuard Key Ceremony is the process used by Election Officials to share encryption keys for an election. Before an election, a fixed number of Guardians are selection to hold the private keys needed to decrypt the election results. A Quorum count of Guardians can also be specified to compensate for guardians who may be missing at the time of Decryption. For instance, 5 Guardians may be selected to hold the keys, but only 3 of them are required to decrypt the election results. Guardians are typically Election Officials, Trustees Canvass Board Members, Government Officials or other trusted authorities who are responsible and accountable for conducting the election. Summary The Key Ceremony is broken into several high-level steps. Each Guardian must announce their attendance in the key ceremony, generate their own public-private key pairs, and then share those key pairs with the Quorum. Then the data that is shared is mathematically verified using Non-Interactive Zero Knowledge Proofs, and finally a joint public key is created to encrypt ballots in the election. Attendance Guardians exchange all public keys and ensure each fellow guardian has received an election and auxiliary public key ensuring at all guardians are in attendance. Key Sharing Guardians generate a partial key backup for each guardian and share with that designated key with that guardian. Then each designated guardian sends a verification back to the sender. The sender then publishes to the group when all verifications are received. Joint Key The final step is to publish the joint election key after all keys and backups have been shared. Glossary Guardian A guardian of the election who holds the ability to partially decrypt the election results Key Ceremony Mediator A mediator to mediate communication (if needed) of information such as keys between the guardians Election Key Pair: Pair of keys (public & secret) used to encrypt/decrypt election Auxiliary Key Pair: Pair of keys (public & secret) used to encrypt/decrypt information sent between guardians Election Partial Key Backup: A point on a secret polynomial and commitments to verify this point for a designated guardian. Election Polynomial: The election polynomial is the mathematical expression that each Guardian defines to solve for his or her private key. A different point associated with the polynomial is shared with each of the other guardians so that the guardians can come together to derive the polynomial function and solve for the private key. Joint Key: Combined public key from election public keys of each guardian Quorum: Quantity of guardians (k) that is required to decrypt the election and is less than the total number of guardians available (n) Process This is a detailed description of the entire Key Ceremony Process The ceremony details are decided upon. These include a number_of_guardians and quorum of guardians required for decryption. Each guardian creates a unique id and sequence_order . Each guardian must generate their auxiliary key pair .* Each guardian must give the other guardians their auxiliary public key directly or through a mediator. Each guardian must check if all auxiliary public keys are received. Each guardian must generate their election key pair (ElGamal key pair) . This will generate a corresponding Schnorr proof and polynomial used for generating election partial key backups for sharing. Each guardian must give the other guardians their election public key directly or through a mediator. Each guardian must check if all election public keys are received. Each guardian must generate election partial key backup for each other guardian. The guardian will use their polynomial and the designated guardian's sequence_order to create the value. The backup will be encrypted with the designated guardian's auxiliary public key * Each guardian must send each encrypted election partial key backup to the designated guardian directly or through a mediator . Each guardian checks if all encrypted election partial key backups have been received by their recipient guardian directly or through a mediator. Each recipient guardian decrypts each received encrypted election partial key backup with their own auxiliary private key * Each recipient guardian verifies each election partial key backup and sends confirmation of verification If the proof verifies, continue If the proof fails Sender guardian publishes the election partial key backup value sent to recipient as a election partial key challenge where the value is unencrypted to all the other guardians ** Alternate guardian (outside sender or original recipient) attempts to verify key If the proof verifies, continue If the proof fails again, the accused (sender guardian) should be evicted and process should be restarted with new guardian. On receipt of all verifications of election partial private keys by all guardians, generate and publish joint key from election public keys. * Note: The auxiliary encrypt and decrypt functions can be overridden to allow different encryption mechanisms other than the default. ** Note: The confidentiality of this value is now gone, but since the two Guardians are in the dispute, at least one is misbehaving and could be revealing this data. Files key_ceremony.py guardian.py key_ceremony_mediator.py Usage Example This example demonstrates a convenience method to generate guardians for an election NUMBER_OF_GUARDIANS: int QUORUM: int details: CeremonyDetails guardians: List[Guardian] # Setup Guardians for i in range(NUMBER_OF_GUARDIANS): guardians.append( Guardian(f\"some_guardian_id_{str(i)}\", i, NUMBER_OF_GUARDIANS, QUORUM) ) mediator = KeyCeremonyMediator(details) # Attendance (Public Key Share) for guardian in guardians: mediator.announce(guardian) # Orchestation (Private Key Share) orchestrated = mediator.orchestrate() # Verify (Prove the guardians acted in good faith) verified = mediator.verify() # Publish the Joint Public Key joint_public_key = mediator.publish_joint_key() Implementation Considerations ElectionGuard can be run without the key ceremony. The key ceremony is the recommended process to generate keys for live end-to-end verifiable elections, however this process may not be necessary for other use cases such as privacy preserving risk limiting audits.","title":"1. Key Ceremony"},{"location":"1_Key_Ceremony/#key-ceremony","text":"The ElectionGuard Key Ceremony is the process used by Election Officials to share encryption keys for an election. Before an election, a fixed number of Guardians are selection to hold the private keys needed to decrypt the election results. A Quorum count of Guardians can also be specified to compensate for guardians who may be missing at the time of Decryption. For instance, 5 Guardians may be selected to hold the keys, but only 3 of them are required to decrypt the election results. Guardians are typically Election Officials, Trustees Canvass Board Members, Government Officials or other trusted authorities who are responsible and accountable for conducting the election.","title":"Key Ceremony"},{"location":"1_Key_Ceremony/#summary","text":"The Key Ceremony is broken into several high-level steps. Each Guardian must announce their attendance in the key ceremony, generate their own public-private key pairs, and then share those key pairs with the Quorum. Then the data that is shared is mathematically verified using Non-Interactive Zero Knowledge Proofs, and finally a joint public key is created to encrypt ballots in the election.","title":"Summary"},{"location":"1_Key_Ceremony/#attendance","text":"Guardians exchange all public keys and ensure each fellow guardian has received an election and auxiliary public key ensuring at all guardians are in attendance.","title":"Attendance"},{"location":"1_Key_Ceremony/#key-sharing","text":"Guardians generate a partial key backup for each guardian and share with that designated key with that guardian. Then each designated guardian sends a verification back to the sender. The sender then publishes to the group when all verifications are received.","title":"Key Sharing"},{"location":"1_Key_Ceremony/#joint-key","text":"The final step is to publish the joint election key after all keys and backups have been shared.","title":"Joint Key"},{"location":"1_Key_Ceremony/#glossary","text":"Guardian A guardian of the election who holds the ability to partially decrypt the election results Key Ceremony Mediator A mediator to mediate communication (if needed) of information such as keys between the guardians Election Key Pair: Pair of keys (public & secret) used to encrypt/decrypt election Auxiliary Key Pair: Pair of keys (public & secret) used to encrypt/decrypt information sent between guardians Election Partial Key Backup: A point on a secret polynomial and commitments to verify this point for a designated guardian. Election Polynomial: The election polynomial is the mathematical expression that each Guardian defines to solve for his or her private key. A different point associated with the polynomial is shared with each of the other guardians so that the guardians can come together to derive the polynomial function and solve for the private key. Joint Key: Combined public key from election public keys of each guardian Quorum: Quantity of guardians (k) that is required to decrypt the election and is less than the total number of guardians available (n)","title":"Glossary"},{"location":"1_Key_Ceremony/#process","text":"This is a detailed description of the entire Key Ceremony Process The ceremony details are decided upon. These include a number_of_guardians and quorum of guardians required for decryption. Each guardian creates a unique id and sequence_order . Each guardian must generate their auxiliary key pair .* Each guardian must give the other guardians their auxiliary public key directly or through a mediator. Each guardian must check if all auxiliary public keys are received. Each guardian must generate their election key pair (ElGamal key pair) . This will generate a corresponding Schnorr proof and polynomial used for generating election partial key backups for sharing. Each guardian must give the other guardians their election public key directly or through a mediator. Each guardian must check if all election public keys are received. Each guardian must generate election partial key backup for each other guardian. The guardian will use their polynomial and the designated guardian's sequence_order to create the value. The backup will be encrypted with the designated guardian's auxiliary public key * Each guardian must send each encrypted election partial key backup to the designated guardian directly or through a mediator . Each guardian checks if all encrypted election partial key backups have been received by their recipient guardian directly or through a mediator. Each recipient guardian decrypts each received encrypted election partial key backup with their own auxiliary private key * Each recipient guardian verifies each election partial key backup and sends confirmation of verification If the proof verifies, continue If the proof fails Sender guardian publishes the election partial key backup value sent to recipient as a election partial key challenge where the value is unencrypted to all the other guardians ** Alternate guardian (outside sender or original recipient) attempts to verify key If the proof verifies, continue If the proof fails again, the accused (sender guardian) should be evicted and process should be restarted with new guardian. On receipt of all verifications of election partial private keys by all guardians, generate and publish joint key from election public keys. * Note: The auxiliary encrypt and decrypt functions can be overridden to allow different encryption mechanisms other than the default. ** Note: The confidentiality of this value is now gone, but since the two Guardians are in the dispute, at least one is misbehaving and could be revealing this data.","title":"Process"},{"location":"1_Key_Ceremony/#files","text":"key_ceremony.py guardian.py key_ceremony_mediator.py","title":"Files"},{"location":"1_Key_Ceremony/#usage-example","text":"This example demonstrates a convenience method to generate guardians for an election NUMBER_OF_GUARDIANS: int QUORUM: int details: CeremonyDetails guardians: List[Guardian] # Setup Guardians for i in range(NUMBER_OF_GUARDIANS): guardians.append( Guardian(f\"some_guardian_id_{str(i)}\", i, NUMBER_OF_GUARDIANS, QUORUM) ) mediator = KeyCeremonyMediator(details) # Attendance (Public Key Share) for guardian in guardians: mediator.announce(guardian) # Orchestation (Private Key Share) orchestrated = mediator.orchestrate() # Verify (Prove the guardians acted in good faith) verified = mediator.verify() # Publish the Joint Public Key joint_public_key = mediator.publish_joint_key()","title":"Usage Example"},{"location":"1_Key_Ceremony/#implementation-considerations","text":"ElectionGuard can be run without the key ceremony. The key ceremony is the recommended process to generate keys for live end-to-end verifiable elections, however this process may not be necessary for other use cases such as privacy preserving risk limiting audits.","title":"Implementation Considerations"},{"location":"2_Encrypt_Ballots/","text":"Encrypt Ballots The primary function of ElectionGuard is to encrypt ballots. Ballots are encrypted on a uniquely identified device within the context of a specific election. The election public key is used to encrypt ballots. A master nonce value is generated for each ballot and the nonce is used to derive other nonce values for encrypting the selection on each ballot. Glossary Plaintext Ballot - The plaintext representation of a voter's selections Ciphertext Ballot - The encrypted representation of a voter's selections Master Nonce - A random number used to derive encryptions in a CiphertextBallot Verification Code or Ballot Code - A unique hash value generated by an Encryption Device to anonymously identify a ballot Encryption Device The device that is doing the encryption Process Verify the ballot is well-formed against the Election Metadata ( InternalManifest ) Generate a random master nonce value to use as a secret when encrypting the ballot Using the metadata of the election and the master nonce, encrypt each selection on the ballot For each selection on the ballot, generate a disjunctive Non-Interactive Zero-Knowledge Proof that the encryption is either an encryption of zero or one For each contest on the ballot, generate a Non-Interactive Zero-Knowledge Proof that the sum of all encrypted ballots is equal to the selection limit on the contest Generate a verification code for the ballot Usage Example internal_manifest: InternalManifest context: CiphertextElectionContext ballot: PlaintextBallot # Configure an encryption device device = EncryptionDevice(generate_device_uuid(), \"Session\", 12345, \"polling-place-one\") encrypter = EncryptionMediator(internal_manifest, context, device) # Encrypt the ballot encrypted_ballot: CiphertextBallot = encrypter.encrypt(ballot) Implementation Considerations When encrypting a ballot, a new ballot object is created that is associated with the plaintext ballot. The encrypted representation includes all of the encryptions, hash values, nonce values, and proofs generated at each step. For the primary end-to-end election workflow, consumers of this API should separate the nonce values from the CiphertextBallot prior to publishing the encrypted ballot representation.","title":"2. Encrypt Ballots"},{"location":"2_Encrypt_Ballots/#encrypt-ballots","text":"The primary function of ElectionGuard is to encrypt ballots. Ballots are encrypted on a uniquely identified device within the context of a specific election. The election public key is used to encrypt ballots. A master nonce value is generated for each ballot and the nonce is used to derive other nonce values for encrypting the selection on each ballot.","title":"Encrypt Ballots"},{"location":"2_Encrypt_Ballots/#glossary","text":"Plaintext Ballot - The plaintext representation of a voter's selections Ciphertext Ballot - The encrypted representation of a voter's selections Master Nonce - A random number used to derive encryptions in a CiphertextBallot Verification Code or Ballot Code - A unique hash value generated by an Encryption Device to anonymously identify a ballot Encryption Device The device that is doing the encryption","title":"Glossary"},{"location":"2_Encrypt_Ballots/#process","text":"Verify the ballot is well-formed against the Election Metadata ( InternalManifest ) Generate a random master nonce value to use as a secret when encrypting the ballot Using the metadata of the election and the master nonce, encrypt each selection on the ballot For each selection on the ballot, generate a disjunctive Non-Interactive Zero-Knowledge Proof that the encryption is either an encryption of zero or one For each contest on the ballot, generate a Non-Interactive Zero-Knowledge Proof that the sum of all encrypted ballots is equal to the selection limit on the contest Generate a verification code for the ballot","title":"Process"},{"location":"2_Encrypt_Ballots/#usage-example","text":"internal_manifest: InternalManifest context: CiphertextElectionContext ballot: PlaintextBallot # Configure an encryption device device = EncryptionDevice(generate_device_uuid(), \"Session\", 12345, \"polling-place-one\") encrypter = EncryptionMediator(internal_manifest, context, device) # Encrypt the ballot encrypted_ballot: CiphertextBallot = encrypter.encrypt(ballot)","title":"Usage Example"},{"location":"2_Encrypt_Ballots/#implementation-considerations","text":"When encrypting a ballot, a new ballot object is created that is associated with the plaintext ballot. The encrypted representation includes all of the encryptions, hash values, nonce values, and proofs generated at each step. For the primary end-to-end election workflow, consumers of this API should separate the nonce values from the CiphertextBallot prior to publishing the encrypted ballot representation.","title":"Implementation Considerations"},{"location":"3_Cast_and_Spoil/","text":"Cast and Spoil Ballots Each ballot that is completed by a voter must be either cast or spoiled. A cast ballot is a ballot that the voter accepts as valid and wishes to include in the official election tally. A spoiled ballot, also referred to as a challenged ballot, is a ballot that the voter does not accept as valid and wishes to exclude from the official election tally. ElectionGuard includes a mechanism to mark a specific ballot as either cast or spoiled. Cast ballots are included in the tally record, while spoiled ballots are not. Spoiled ballots are decrypted into plaintext and published along with the rest of the election record. Jurisdictional Differences Depending on the jurisdiction conducting an election the process of casting and spoiling ballots may be handled differently. For this reason, there are multiple ways to interact with the BallotBox and Tally . By calling accept_ballot - Ballots can be marked cast or spoiled manually. By using the Ballot Box - Ballots can be marked cast or spoiled using a stateful class. Unknown Ballots In some jurisdictions, there is a limit on the number of ballots that may be marked as spoiled. If this is the case, you may use the BallotBoxState.UNKNOWN state, or extend the enumeration to support your specific use case. Encrypted Tally Once all of the ballots are marked as cast or spoiled , all of the encryptions of each option are homomorphically combined to form an encryption of the total number of times that each option was selected in the election. This process is completed only for cast ballot. The spoiled ballots are simply marked for inclusion in the election results. Glossary Ciphertext Ballot An encrypted representation of a voter's filled-in ballot. Submitted Ballot A wrapper around the CiphertextBallot that represents a ballot that is submitted for inclusion in election results and is either: cast or spoiled. Ballot Box A stateful collection of ballots that are either cast or spoiled. Ballot Store A repository for retaining cast and spoiled ballots. Cast Ballot A ballot which a voter has accepted as valid to be included in the official election tally. Spoiled Ballot A ballot which a voter did not accept as valid and is not included in the tally. Unknown Ballot A ballot which may not yet be determined as cast or spoiled, or that may have been spoiled but is otherwise not published in the election results. Homomorphic Tally An encrypted representation of every selection on every ballot that was cast. This representation is stored in a CiphertextTally object. Process Each ballot is loaded into memory (if it is not already). Each ballot is verified to be correct according to the specific election metadata and encryption context. Each ballot is submitted and identified as either being cast or spoiled . The collection of cast and spoiled ballots is cached in the DataStore . All ballots are tallied. The cast ballots are combined to create a CiphertextTally The spoiled ballots are cached for decryption later. Ballot Box The ballot box can be interacted with via a stateful class that caches the election context, or via stateless functions. The following examples demonstrate some ways to interact with the ballot box. Depending on the specific election workflow, the BallotBox class may not be used for a given election. For instance, in one case a ballot can be submitted directly on an electronic device, in which case there is no BallotBox . In a different workflow, a ballot may be explicitly cast or spoiled in a later step, such as after printing for voter review. In all cases, a ballot must be marked as either cast or spoiled to be included in a tally result. Class Example from electionguard.ballot_box import BallotBox internal_manifest: InternalManifest encryption: CiphertextElection store: DataStore ballots_to_cast: List[CiphertextBallot] ballots_to_spoil: List[CiphertextBallot] # The Ballot Box is a thin wrapper around the `accept_ballot` function method ballot_box = BallotBox(internal_manifest, encryption, store) # Cast the ballots for ballot in ballots_to_cast: submitted_ballot = ballot_box.cast(ballot) # The ballot is both returned, and placed into the ballot store assert(store.get(submitted_ballot.object_id) == submitted_ballot) # Spoil the ballots for ballot in ballots_to_spoil: assert(ballot_box.spoil(ballot) is not None) Function Example from electionguard.ballot_box import accept_ballot internal_manifest: InternalManifest encryption: CiphertextElection store: DataStore ballots_to_cast: List[CiphertextBallot] ballots_to_spoil: List[CiphertextBallot] for ballot in ballots_to_cast: submitted_ballot = accept_ballot( ballot, BallotBoxState.CAST, internal_manifest, encryption, store ) for ballot in ballots_to_spoil: submitted_ballot = accept_ballot( ballot, BallotBoxState.SPOILED, internal_manifest, encryption, store ) Tally Generating the encrypted CiphertextTally can be completed by creating a CiphertextTally stateful class and manually marshalling each cast and spoiled ballot. Using this method is preferable when the collection of ballots is very large For convenience, stateless functions are also provided to automatically generate the CiphertextTally from a DataStore . This method is preferred when the collection of ballots is arbitrarily small, or when the DataStore is overloaded with a custom implementation. Using the Stateful Class internal_manifest: InternalManifest context: CiphertextElectionContext ballots: List[SubmittedBallot] tally = CiphertextTally(internal_manifest, context) for ballot in ballots: assert(tally.append(ballot)) Functional Method internal_manifest: InternalManifest context: CiphertextElectionContext store: DataStore tally = tally_ballots(store, internal_manifest, context) assert(tally is not None)","title":"3. Cast and Spoil"},{"location":"3_Cast_and_Spoil/#cast-and-spoil-ballots","text":"Each ballot that is completed by a voter must be either cast or spoiled. A cast ballot is a ballot that the voter accepts as valid and wishes to include in the official election tally. A spoiled ballot, also referred to as a challenged ballot, is a ballot that the voter does not accept as valid and wishes to exclude from the official election tally. ElectionGuard includes a mechanism to mark a specific ballot as either cast or spoiled. Cast ballots are included in the tally record, while spoiled ballots are not. Spoiled ballots are decrypted into plaintext and published along with the rest of the election record.","title":"Cast and Spoil Ballots"},{"location":"3_Cast_and_Spoil/#jurisdictional-differences","text":"Depending on the jurisdiction conducting an election the process of casting and spoiling ballots may be handled differently. For this reason, there are multiple ways to interact with the BallotBox and Tally . By calling accept_ballot - Ballots can be marked cast or spoiled manually. By using the Ballot Box - Ballots can be marked cast or spoiled using a stateful class.","title":"Jurisdictional Differences"},{"location":"3_Cast_and_Spoil/#unknown-ballots","text":"In some jurisdictions, there is a limit on the number of ballots that may be marked as spoiled. If this is the case, you may use the BallotBoxState.UNKNOWN state, or extend the enumeration to support your specific use case.","title":"Unknown Ballots"},{"location":"3_Cast_and_Spoil/#encrypted-tally","text":"Once all of the ballots are marked as cast or spoiled , all of the encryptions of each option are homomorphically combined to form an encryption of the total number of times that each option was selected in the election. This process is completed only for cast ballot. The spoiled ballots are simply marked for inclusion in the election results.","title":"Encrypted Tally"},{"location":"3_Cast_and_Spoil/#glossary","text":"Ciphertext Ballot An encrypted representation of a voter's filled-in ballot. Submitted Ballot A wrapper around the CiphertextBallot that represents a ballot that is submitted for inclusion in election results and is either: cast or spoiled. Ballot Box A stateful collection of ballots that are either cast or spoiled. Ballot Store A repository for retaining cast and spoiled ballots. Cast Ballot A ballot which a voter has accepted as valid to be included in the official election tally. Spoiled Ballot A ballot which a voter did not accept as valid and is not included in the tally. Unknown Ballot A ballot which may not yet be determined as cast or spoiled, or that may have been spoiled but is otherwise not published in the election results. Homomorphic Tally An encrypted representation of every selection on every ballot that was cast. This representation is stored in a CiphertextTally object.","title":"Glossary"},{"location":"3_Cast_and_Spoil/#process","text":"Each ballot is loaded into memory (if it is not already). Each ballot is verified to be correct according to the specific election metadata and encryption context. Each ballot is submitted and identified as either being cast or spoiled . The collection of cast and spoiled ballots is cached in the DataStore . All ballots are tallied. The cast ballots are combined to create a CiphertextTally The spoiled ballots are cached for decryption later.","title":"Process"},{"location":"3_Cast_and_Spoil/#ballot-box","text":"The ballot box can be interacted with via a stateful class that caches the election context, or via stateless functions. The following examples demonstrate some ways to interact with the ballot box. Depending on the specific election workflow, the BallotBox class may not be used for a given election. For instance, in one case a ballot can be submitted directly on an electronic device, in which case there is no BallotBox . In a different workflow, a ballot may be explicitly cast or spoiled in a later step, such as after printing for voter review. In all cases, a ballot must be marked as either cast or spoiled to be included in a tally result.","title":"Ballot Box"},{"location":"3_Cast_and_Spoil/#class-example","text":"from electionguard.ballot_box import BallotBox internal_manifest: InternalManifest encryption: CiphertextElection store: DataStore ballots_to_cast: List[CiphertextBallot] ballots_to_spoil: List[CiphertextBallot] # The Ballot Box is a thin wrapper around the `accept_ballot` function method ballot_box = BallotBox(internal_manifest, encryption, store) # Cast the ballots for ballot in ballots_to_cast: submitted_ballot = ballot_box.cast(ballot) # The ballot is both returned, and placed into the ballot store assert(store.get(submitted_ballot.object_id) == submitted_ballot) # Spoil the ballots for ballot in ballots_to_spoil: assert(ballot_box.spoil(ballot) is not None)","title":"Class Example"},{"location":"3_Cast_and_Spoil/#function-example","text":"from electionguard.ballot_box import accept_ballot internal_manifest: InternalManifest encryption: CiphertextElection store: DataStore ballots_to_cast: List[CiphertextBallot] ballots_to_spoil: List[CiphertextBallot] for ballot in ballots_to_cast: submitted_ballot = accept_ballot( ballot, BallotBoxState.CAST, internal_manifest, encryption, store ) for ballot in ballots_to_spoil: submitted_ballot = accept_ballot( ballot, BallotBoxState.SPOILED, internal_manifest, encryption, store )","title":"Function Example"},{"location":"3_Cast_and_Spoil/#tally","text":"Generating the encrypted CiphertextTally can be completed by creating a CiphertextTally stateful class and manually marshalling each cast and spoiled ballot. Using this method is preferable when the collection of ballots is very large For convenience, stateless functions are also provided to automatically generate the CiphertextTally from a DataStore . This method is preferred when the collection of ballots is arbitrarily small, or when the DataStore is overloaded with a custom implementation.","title":"Tally"},{"location":"3_Cast_and_Spoil/#using-the-stateful-class","text":"internal_manifest: InternalManifest context: CiphertextElectionContext ballots: List[SubmittedBallot] tally = CiphertextTally(internal_manifest, context) for ballot in ballots: assert(tally.append(ballot))","title":"Using the Stateful Class"},{"location":"3_Cast_and_Spoil/#functional-method","text":"internal_manifest: InternalManifest context: CiphertextElectionContext store: DataStore tally = tally_ballots(store, internal_manifest, context) assert(tally is not None)","title":"Functional Method"},{"location":"4_Decrypt_Tally/","text":"Decryption At the conclusion of voting, all of the cast ballots are published in their encrypted form in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically-combined to form an encryption of the total number of times that each option was selected. The homomorphically-combined encryptions are decrypted to generate the election tally. Individual cast ballots are not decrypted. Individual spoiled ballots are decrypted and the plaintext values are published along with the encrypted representations and the proofs. In order to decrypt the homomorphically-combined encryption of each selection, each Guardian participating in the decryption must compute a specific Decryption Share of the decryption. It is preferable that all guardians be present for decryption, however in the event that guardians cannot be present, Electionguard includes a mechanism to decrypt with the Quorum of Guardians . During the Key Ceremony a Quorum of Guardians is defined that represents the minimum number of guardians that must be present to decrypt the election. If the decryption is to proceed with a Quorum of Guardians greater than or equal to the Quorum count, but less than the total number of guardians, then a subset of the Available Guardians must also each construct a Partial Decryption Share for the missing Missing Guardian , in addition to providing their own Decryption Share . It is important to note that mathematically not every present guardian has to compute a Partial Decryption Share for every Missing Guardian . Only the Quorum Count of guardians are necessary to construct Partial Decryption Shares in order to compensate for any Missing Guardian. In this implementation, we take an approach that utilizes all Available Guardians to compensate for Missing Guardians. When it is determined that guardians are missing, all available guardians each calculate a Partial Decryption Share for the missing guardian and publish the result. A Quorum of Guardians count of available Partial Decryption Shares is randomly selected from the pool of available partial decryption shares for a given Missing Guardian . If more than one guardian is missing, we randomly choose to ignore the Partial Decryption Share provided by one of the Available Guardians whose partial decryption share was chosen for the previous Missing Guardian, and randomly select again from the pool of available Partial Decryption Shares. This ensures that all available guardians have the opportunity to participate in compensating for Missing Guardians. Glossary Guardian A guardian of the election who holds the ability to partially decrypt the election results Decryption Share A guardian's partial share of a decryption Encrypted Tally The homomorphically-combined and encrypted representation of all selections made for each option on every contest in the election. See Ballot Box for more information. Key Ceremony The process conducted at the beginning of the election to create the joint encryption context for encrypting ballots during the election. See Key Ceremony for more information. Quorum of Guardians The minimum count ( threshold ) of guardians that must be present in order to successfully decrypt the election results. Available Guardian A guardian that has announced as present for the decryption phase Missing Guardian A guardian who was configured during the Key Ceremony but who is not present for the decryption of the election results. Compensated Decryption Share - a partial decryption share value computed by an available guardian to compensate for a missing guardian so that the missing guardian's share can be generated and the election results can be successfully decrypted. Decryption Mediator - A component or actor responsible for composing each guardian's partial decryptions or compensated decryptions into the plaintext tally Process Each Guardian that will participate in the decryption process computes a Decryption Share of the Ciphertext Tally . Each Guardian also computes a Chaum-Pedersen proof of correctness of their Decryption Share . Decryption when All Guardians are Present If all guardians are present, the Decryption Shares are combined to generate a tally for each option on every contest Decryption when some Guardians are Missing warning: The functionality described in this segment is still a \ud83d\udea7 Work In Progress When one or more of the Guardians are missing, any subset of the Guardians that are present can use the information they have about the other guardian's private keys to reconstruct the partial decryption shares for the missing guardians. Each Available Guardian computes a Partial Decryption Share for each Missing Guardian at least a Quorum count of Partial Decryption Shares are chosen from the values generated in the previous step for a specific Missing guardian Each chosen Available Guardian uses its Partial Decryption Share to compute a share of the missing partial decryption. the process is re-run until all Missing Guardians are compensated for. The Compensated Decryption Shares are combined to reconstruct the missing TallyDecryptionShare finally, all of the DecryptionShares are combined to generate a tally for each option on every contest Challenged/Spoiled Ballots If a ballot is not to be included in the vote count, it is considered challenged, or Spoiled . Every ballot spoiled in an election is individually verifiably decrypted in exactly the same way that the aggregate ballot of tallies is decrypted. Since spoiled ballots are not included as part of the vote count, they are included in the Election Record with their plaintext values included along with the encrypted representations. Spoiling ballots is an important part of the ElectionGuard process as it allows voters to explicitly generate challenge ballots that are verifiable as part of the Election Record. Usage Example Here is a simple example of how to execute the decryption process. internal_manifest: InternalManifest # Load the election manifest context: CiphertextElectionContext # Load the election encryption context encrypted_Tally: CiphertextTally # Provide a tally from the previous step available_guardians: List[Guardian] # Provite the list of guardians who will participate missing_guardians: List[str] # Provide a list of guardians who will not participate mediator = DecryptionMediator(internal_manifest, context, encrypted_tally) # Loop through the available guardians and annouce their presence for guardian in available_guardians: if (mediator.announce(guardian) is None): break # loop through the missing guardians and compensate for them for guardian in missing_guardians: if (mediator.compensate(guardian) is None): break # Generate the plaintext tally plaintext_tally = mediator.get_plaintext_tally() # The plaintext tally automatically includes the election tally and the spoiled ballots contest_tallies = plaintext_tally.contests spoiled_ballots = plaintext_tally.spoiled_ballots Implementation Considerations In certain use cases where the Key Ceremony is not used, ballots and tallies can be decrypted directly using the secret key of the election. See the Tally Tests for an example of how to decrypt the tally using the secret key.","title":"4. Decrypt Tally"},{"location":"4_Decrypt_Tally/#decryption","text":"At the conclusion of voting, all of the cast ballots are published in their encrypted form in the election record together with the proofs that the ballots are well-formed. Additionally, all of the encryptions of each option are homomorphically-combined to form an encryption of the total number of times that each option was selected. The homomorphically-combined encryptions are decrypted to generate the election tally. Individual cast ballots are not decrypted. Individual spoiled ballots are decrypted and the plaintext values are published along with the encrypted representations and the proofs. In order to decrypt the homomorphically-combined encryption of each selection, each Guardian participating in the decryption must compute a specific Decryption Share of the decryption. It is preferable that all guardians be present for decryption, however in the event that guardians cannot be present, Electionguard includes a mechanism to decrypt with the Quorum of Guardians . During the Key Ceremony a Quorum of Guardians is defined that represents the minimum number of guardians that must be present to decrypt the election. If the decryption is to proceed with a Quorum of Guardians greater than or equal to the Quorum count, but less than the total number of guardians, then a subset of the Available Guardians must also each construct a Partial Decryption Share for the missing Missing Guardian , in addition to providing their own Decryption Share . It is important to note that mathematically not every present guardian has to compute a Partial Decryption Share for every Missing Guardian . Only the Quorum Count of guardians are necessary to construct Partial Decryption Shares in order to compensate for any Missing Guardian. In this implementation, we take an approach that utilizes all Available Guardians to compensate for Missing Guardians. When it is determined that guardians are missing, all available guardians each calculate a Partial Decryption Share for the missing guardian and publish the result. A Quorum of Guardians count of available Partial Decryption Shares is randomly selected from the pool of available partial decryption shares for a given Missing Guardian . If more than one guardian is missing, we randomly choose to ignore the Partial Decryption Share provided by one of the Available Guardians whose partial decryption share was chosen for the previous Missing Guardian, and randomly select again from the pool of available Partial Decryption Shares. This ensures that all available guardians have the opportunity to participate in compensating for Missing Guardians.","title":"Decryption"},{"location":"4_Decrypt_Tally/#glossary","text":"Guardian A guardian of the election who holds the ability to partially decrypt the election results Decryption Share A guardian's partial share of a decryption Encrypted Tally The homomorphically-combined and encrypted representation of all selections made for each option on every contest in the election. See Ballot Box for more information. Key Ceremony The process conducted at the beginning of the election to create the joint encryption context for encrypting ballots during the election. See Key Ceremony for more information. Quorum of Guardians The minimum count ( threshold ) of guardians that must be present in order to successfully decrypt the election results. Available Guardian A guardian that has announced as present for the decryption phase Missing Guardian A guardian who was configured during the Key Ceremony but who is not present for the decryption of the election results. Compensated Decryption Share - a partial decryption share value computed by an available guardian to compensate for a missing guardian so that the missing guardian's share can be generated and the election results can be successfully decrypted. Decryption Mediator - A component or actor responsible for composing each guardian's partial decryptions or compensated decryptions into the plaintext tally","title":"Glossary"},{"location":"4_Decrypt_Tally/#process","text":"Each Guardian that will participate in the decryption process computes a Decryption Share of the Ciphertext Tally . Each Guardian also computes a Chaum-Pedersen proof of correctness of their Decryption Share .","title":"Process"},{"location":"4_Decrypt_Tally/#decryption-when-all-guardians-are-present","text":"If all guardians are present, the Decryption Shares are combined to generate a tally for each option on every contest","title":"Decryption when All Guardians are Present"},{"location":"4_Decrypt_Tally/#decryption-when-some-guardians-are-missing","text":"warning: The functionality described in this segment is still a \ud83d\udea7 Work In Progress When one or more of the Guardians are missing, any subset of the Guardians that are present can use the information they have about the other guardian's private keys to reconstruct the partial decryption shares for the missing guardians. Each Available Guardian computes a Partial Decryption Share for each Missing Guardian at least a Quorum count of Partial Decryption Shares are chosen from the values generated in the previous step for a specific Missing guardian Each chosen Available Guardian uses its Partial Decryption Share to compute a share of the missing partial decryption. the process is re-run until all Missing Guardians are compensated for. The Compensated Decryption Shares are combined to reconstruct the missing TallyDecryptionShare finally, all of the DecryptionShares are combined to generate a tally for each option on every contest","title":"Decryption when some Guardians are Missing"},{"location":"4_Decrypt_Tally/#challengedspoiled-ballots","text":"If a ballot is not to be included in the vote count, it is considered challenged, or Spoiled . Every ballot spoiled in an election is individually verifiably decrypted in exactly the same way that the aggregate ballot of tallies is decrypted. Since spoiled ballots are not included as part of the vote count, they are included in the Election Record with their plaintext values included along with the encrypted representations. Spoiling ballots is an important part of the ElectionGuard process as it allows voters to explicitly generate challenge ballots that are verifiable as part of the Election Record.","title":"Challenged/Spoiled Ballots"},{"location":"4_Decrypt_Tally/#usage-example","text":"Here is a simple example of how to execute the decryption process. internal_manifest: InternalManifest # Load the election manifest context: CiphertextElectionContext # Load the election encryption context encrypted_Tally: CiphertextTally # Provide a tally from the previous step available_guardians: List[Guardian] # Provite the list of guardians who will participate missing_guardians: List[str] # Provide a list of guardians who will not participate mediator = DecryptionMediator(internal_manifest, context, encrypted_tally) # Loop through the available guardians and annouce their presence for guardian in available_guardians: if (mediator.announce(guardian) is None): break # loop through the missing guardians and compensate for them for guardian in missing_guardians: if (mediator.compensate(guardian) is None): break # Generate the plaintext tally plaintext_tally = mediator.get_plaintext_tally() # The plaintext tally automatically includes the election tally and the spoiled ballots contest_tallies = plaintext_tally.contests spoiled_ballots = plaintext_tally.spoiled_ballots","title":"Usage Example"},{"location":"4_Decrypt_Tally/#implementation-considerations","text":"In certain use cases where the Key Ceremony is not used, ballots and tallies can be decrypted directly using the secret key of the election. See the Tally Tests for an example of how to decrypt the tally using the secret key.","title":"Implementation Considerations"},{"location":"5_Publish_and_Verify/","text":"Publish and Verify Publish Publishing the election artifacts helps ensure third parties can verify the election. publish.py provides a publish method that serializes the key election artifacts. This makes use of the Serializable class exists to allow easy serializing to json files. These JSON files can then be shared and sent so others can verify. Verify Deserializing is the first step to verification. The from_json and from_json_file methods on Serializable are available to deserialize output JSON files back into their original classes.","title":"5. Publish and Verify"},{"location":"5_Publish_and_Verify/#publish-and-verify","text":"","title":"Publish and Verify"},{"location":"5_Publish_and_Verify/#publish","text":"Publishing the election artifacts helps ensure third parties can verify the election. publish.py provides a publish method that serializes the key election artifacts. This makes use of the Serializable class exists to allow easy serializing to json files. These JSON files can then be shared and sent so others can verify.","title":"Publish"},{"location":"5_Publish_and_Verify/#verify","text":"Deserializing is the first step to verification. The from_json and from_json_file methods on Serializable are available to deserialize output JSON files back into their original classes.","title":"Verify"},{"location":"Build_and_Run/","text":"Build and Run These instructions can be used to build and run the project. Setup 1. Initialize dev environment make environment OR pipenv install --dev 2. Install the electionguard module in edit mode make install OR pipenv run python -m pip install -e . \u26a0\ufe0f Note: For Windows without make , use supplied precompiled gmpy2 package with the --find-links or -f option. The 32 vs 64 bit is based on your installed python version NOT your system. Determine if 64-bit: This code snippet will read true for 64 bit. python -c 'from sys import maxsize; print(maxsize > 2**32)' Install module with link 32-bit: pipenv run pip install -f packages/gmpy2-2.0.8-cp38-cp38-win32.whl -e . 64-bit: pipenv run pip install -f packages/gmpy2-2.0.8-cp38-cp38-win_amd64 -e . 3. Validate import of module (Optional) make validate OR pipenv run python -c 'import electionguard; print(electionguard.__package__ + \" successfully imported\")' Running Option 1: Code Coverage make coverage OR pipenv run coverage report Option 2: Run tests in VS Code Install recommended test explorer extensions and run unit tests through tool. \u26a0\ufe0f Note: For Windows, be sure to select the virtual environment Python interpreter . Option 3: Run test command make test OR pipenv run python -m pytest /testss","title":"Build and Run"},{"location":"Build_and_Run/#build-and-run","text":"These instructions can be used to build and run the project.","title":"Build and Run"},{"location":"Build_and_Run/#setup","text":"","title":"Setup"},{"location":"Build_and_Run/#1-initialize-dev-environment","text":"make environment OR pipenv install --dev","title":"1. Initialize dev environment"},{"location":"Build_and_Run/#2-install-the-electionguard-module-in-edit-mode","text":"make install OR pipenv run python -m pip install -e . \u26a0\ufe0f Note: For Windows without make , use supplied precompiled gmpy2 package with the --find-links or -f option. The 32 vs 64 bit is based on your installed python version NOT your system. Determine if 64-bit: This code snippet will read true for 64 bit. python -c 'from sys import maxsize; print(maxsize > 2**32)' Install module with link 32-bit: pipenv run pip install -f packages/gmpy2-2.0.8-cp38-cp38-win32.whl -e . 64-bit: pipenv run pip install -f packages/gmpy2-2.0.8-cp38-cp38-win_amd64 -e .","title":"2. Install the electionguard module in edit mode"},{"location":"Build_and_Run/#3-validate-import-of-module-optional","text":"make validate OR pipenv run python -c 'import electionguard; print(electionguard.__package__ + \" successfully imported\")'","title":"3. Validate import of module (Optional)"},{"location":"Build_and_Run/#running","text":"","title":"Running"},{"location":"Build_and_Run/#option-1-code-coverage","text":"make coverage OR pipenv run coverage report","title":"Option 1: Code Coverage"},{"location":"Build_and_Run/#option-2-run-tests-in-vs-code","text":"Install recommended test explorer extensions and run unit tests through tool. \u26a0\ufe0f Note: For Windows, be sure to select the virtual environment Python interpreter .","title":"Option 2: Run tests in VS Code"},{"location":"Build_and_Run/#option-3-run-test-command","text":"make test OR pipenv run python -m pytest /testss","title":"Option 3: Run test command"},{"location":"Design_and_Architecture/","text":"Design & Architecture This describes the design and architecture of the electionguard-python project. Design \u2705 Simplicity Simplicity is the first and foremost goal of the code. The intent is for others to be able to easily transliterate the code to any other programming language with little more than structures and functions. This simplicity applies to all aspects of the code design, including naming. \u2705 Extendable and Interpretable The library is intentionally general-purpose to support the different use cases of \"end to end verifiable\" voting systems. Different projects may wish to use different layers of the library, including math primitives, encryption functions, and more. \u2705 Object Oriented Design (OOD) & Functional Methods An additional goal is to build a familiar object oriented design with underlying functional style methods. This allows users to simply construct objects in an OOP fashion or directly call the underlying methods in a functional way. This design also facilitates easy testing and composition. Class methods are used for simplicity, but sophistication with regard to inheritance, object encapsulation, or design patterns is intentionally avoided. These class methods usually rely on the aforementioned functional methods unless the class contains state. \u2705 Immutable The library prefers immutable objects where possible to encourage simple data structures. dataclass dataclass uses the object.__setattr__ pattern in _postinit__ functions to support freezing data classes where possible. NamedTuple NamedTuple is frequently used for the library's data structures. They are immutable after creation and have a _replace() method that makes it easy to make a copy replacing only one field. \u2705 Concurrency While this library is not explicitly engineered to use concurrency, it's definitely meant to work properly when the caller wants to run more than one thing at a time. This means there is no global, mutable state in the library with the exception of a discrete-log function doing internal memoization, itself explicitly written to be thread-safe. \u2705 Union Classes For both naming purposes and usability, union classes are generally preferred. This can alleviate issues with multiple inheritance \ud83d\udeab Exceptions To allow for easier transliteration, the library will not raise exception across the API boundary since this is not available in all languages. Instead, the library will have a variety of functions that indicate failures by returning None ; the caller is expected to check if the result is None before any further processing. Python 3 typing calls this sort of result Optional .This tactic also indicates all exceptions raised are expected to be from bugs. \ud83d\udeab Multiple Inheritance Although a handy python feature, for implementation simplicity this feature is not used and should be avoided. Architecture \ud83e\udd1d Approachable The python setup is designed to be as approachable as possible from the environment to the continuous integration. Setup The library contains a Pipfile that can be used with pipenv to ensure the correct dependencies are included, as well as a setup.py to install the package itself. There is also a Makefile which allows for simple make commands to ease new developers into the build process. If the user is a new developer, the recommendation is starting with Visual Studio Code since there are many default settings and recommended extensions in the repository. Folder Structure The folder structure is kept to a bare minimum. The ElectionGuard library is located in src/electionguard and tests are in tests . Standalone applications or other pieces should be in separate subdirectories. For example, the tests/bench directory contains a simple Chaum-Pedersen proof computation benchmark. Commands To simplify the command structure, make is used. A Makefile sits in the root directory and contains useful commands that can be used to run setup. These are shown in use in the continuous integration . \ud83e\uddf9 Clean Code The library uses several tools to assist developers in maintaining clean code. Visual Studio Code is recommended for easier setup. Typing The library uses Python 3 type hints throughout and ensures return types are defined. Mypy is used to statically check the typing. Linting Pylint is used for typing; settings are in the .pylinrc file. Formatting Black is used for auto-formatting and checking the formatting of the python code. Settings are in the pyproject.toml file. \ud83e\uddea Testing The goal of the project is 100% code coverage with an understanding that there are some limitations. Property Based Property testing is helpful for testing certain properties . The library uses Hypothesis property-based testing to vigorously exercise the library. The library includes generator functions for all the core datatypes, making them easy to randomly generate. \ud83d\ude80 Continuous Integration GitHub Actions are being used for continuous integration. Cross-platform is a primary goal and the workflows provided demonstrate how a developer can build in Linux, MacOS, and Windows. The run workflows can be seen on the GitHub repo page or a user can navigate to .github/workflows to inspect them. \ud83d\udce6 Math Library gmpy2 is a multiprecision numeric library that was chosen over Python's built-ins int type for its speed necessary for encryption performance. The current version used is 2.0.8 which is the most stable version. This is necessary for cross-platform since the library uses precompiled libraries for Windows due to reliance on gmp . The gmpy2 options are chosen over the native Python equivalents as shown below. Integers: int -> mpz Exponents: pow -> powmod With the use of mypy for typing and the lack of type presence in Typeshed for gmpy2, the library provides a stub in stubs/gmpy2.pyi to ensure the code compiles without warnings.","title":"Design and Architecture"},{"location":"Design_and_Architecture/#design-architecture","text":"This describes the design and architecture of the electionguard-python project.","title":"Design &amp; Architecture"},{"location":"Design_and_Architecture/#design","text":"","title":"Design"},{"location":"Design_and_Architecture/#simplicity","text":"Simplicity is the first and foremost goal of the code. The intent is for others to be able to easily transliterate the code to any other programming language with little more than structures and functions. This simplicity applies to all aspects of the code design, including naming.","title":"\u2705 Simplicity"},{"location":"Design_and_Architecture/#extendable-and-interpretable","text":"The library is intentionally general-purpose to support the different use cases of \"end to end verifiable\" voting systems. Different projects may wish to use different layers of the library, including math primitives, encryption functions, and more.","title":"\u2705 Extendable and Interpretable"},{"location":"Design_and_Architecture/#object-oriented-design-ood-functional-methods","text":"An additional goal is to build a familiar object oriented design with underlying functional style methods. This allows users to simply construct objects in an OOP fashion or directly call the underlying methods in a functional way. This design also facilitates easy testing and composition. Class methods are used for simplicity, but sophistication with regard to inheritance, object encapsulation, or design patterns is intentionally avoided. These class methods usually rely on the aforementioned functional methods unless the class contains state.","title":"\u2705 Object Oriented Design (OOD) &amp; Functional Methods"},{"location":"Design_and_Architecture/#immutable","text":"The library prefers immutable objects where possible to encourage simple data structures.","title":"\u2705 Immutable"},{"location":"Design_and_Architecture/#dataclass","text":"dataclass uses the object.__setattr__ pattern in _postinit__ functions to support freezing data classes where possible.","title":"dataclass"},{"location":"Design_and_Architecture/#namedtuple","text":"NamedTuple is frequently used for the library's data structures. They are immutable after creation and have a _replace() method that makes it easy to make a copy replacing only one field.","title":"NamedTuple"},{"location":"Design_and_Architecture/#concurrency","text":"While this library is not explicitly engineered to use concurrency, it's definitely meant to work properly when the caller wants to run more than one thing at a time. This means there is no global, mutable state in the library with the exception of a discrete-log function doing internal memoization, itself explicitly written to be thread-safe.","title":"\u2705 Concurrency"},{"location":"Design_and_Architecture/#union-classes","text":"For both naming purposes and usability, union classes are generally preferred. This can alleviate issues with multiple inheritance","title":"\u2705 Union Classes"},{"location":"Design_and_Architecture/#exceptions","text":"To allow for easier transliteration, the library will not raise exception across the API boundary since this is not available in all languages. Instead, the library will have a variety of functions that indicate failures by returning None ; the caller is expected to check if the result is None before any further processing. Python 3 typing calls this sort of result Optional .This tactic also indicates all exceptions raised are expected to be from bugs.","title":"\ud83d\udeab Exceptions"},{"location":"Design_and_Architecture/#multiple-inheritance","text":"Although a handy python feature, for implementation simplicity this feature is not used and should be avoided.","title":"\ud83d\udeab Multiple Inheritance"},{"location":"Design_and_Architecture/#architecture","text":"","title":"Architecture"},{"location":"Design_and_Architecture/#approachable","text":"The python setup is designed to be as approachable as possible from the environment to the continuous integration.","title":"\ud83e\udd1d Approachable"},{"location":"Design_and_Architecture/#setup","text":"The library contains a Pipfile that can be used with pipenv to ensure the correct dependencies are included, as well as a setup.py to install the package itself. There is also a Makefile which allows for simple make commands to ease new developers into the build process. If the user is a new developer, the recommendation is starting with Visual Studio Code since there are many default settings and recommended extensions in the repository.","title":"Setup"},{"location":"Design_and_Architecture/#folder-structure","text":"The folder structure is kept to a bare minimum. The ElectionGuard library is located in src/electionguard and tests are in tests . Standalone applications or other pieces should be in separate subdirectories. For example, the tests/bench directory contains a simple Chaum-Pedersen proof computation benchmark.","title":"Folder Structure"},{"location":"Design_and_Architecture/#commands","text":"To simplify the command structure, make is used. A Makefile sits in the root directory and contains useful commands that can be used to run setup. These are shown in use in the continuous integration .","title":"Commands"},{"location":"Design_and_Architecture/#clean-code","text":"The library uses several tools to assist developers in maintaining clean code. Visual Studio Code is recommended for easier setup.","title":"\ud83e\uddf9 Clean Code"},{"location":"Design_and_Architecture/#typing","text":"The library uses Python 3 type hints throughout and ensures return types are defined. Mypy is used to statically check the typing.","title":"Typing"},{"location":"Design_and_Architecture/#linting","text":"Pylint is used for typing; settings are in the .pylinrc file.","title":"Linting"},{"location":"Design_and_Architecture/#formatting","text":"Black is used for auto-formatting and checking the formatting of the python code. Settings are in the pyproject.toml file.","title":"Formatting"},{"location":"Design_and_Architecture/#testing","text":"The goal of the project is 100% code coverage with an understanding that there are some limitations.","title":"\ud83e\uddea Testing"},{"location":"Design_and_Architecture/#property-based","text":"Property testing is helpful for testing certain properties . The library uses Hypothesis property-based testing to vigorously exercise the library. The library includes generator functions for all the core datatypes, making them easy to randomly generate.","title":"Property Based"},{"location":"Design_and_Architecture/#continuous-integration","text":"GitHub Actions are being used for continuous integration. Cross-platform is a primary goal and the workflows provided demonstrate how a developer can build in Linux, MacOS, and Windows. The run workflows can be seen on the GitHub repo page or a user can navigate to .github/workflows to inspect them.","title":"\ud83d\ude80 Continuous Integration"},{"location":"Design_and_Architecture/#math-library","text":"gmpy2 is a multiprecision numeric library that was chosen over Python's built-ins int type for its speed necessary for encryption performance. The current version used is 2.0.8 which is the most stable version. This is necessary for cross-platform since the library uses precompiled libraries for Windows due to reliance on gmp . The gmpy2 options are chosen over the native Python equivalents as shown below. Integers: int -> mpz Exponents: pow -> powmod With the use of mypy for typing and the lack of type presence in Typeshed for gmpy2, the library provides a stub in stubs/gmpy2.pyi to ensure the code compiles without warnings.","title":"\ud83d\udce6 Math Library"},{"location":"Election_Manifest/","text":"Overview There are many types of elections. We need a base set of data that shows how these different types of elections are handled in an ElectionGuard end-to-end verifiable election (or ballot comparison audits). We worked with InfernoRed, VotingWorks, and Dan Wallach of Rice University (thanks folks!) to develop a set of conventions, tests, and sample data (based on a starting dataset sample from the Center for Civic Design) that demonstrate how to encode the information necessary to conduct an election into a format that ElectionGuard can use. The election terms and structure are based whenever possible on the NIST SP-1500-101 Election Event Logging Common Data Format Specification (with a prettier and (mostly) more functional implementation here and a PDF for version 2 ). The information captured by the NIST standard is codified into an election manifest that defines common elements when conducting an election, such as locations, candidates, parties, contests, and ballot styles. ElectionGuard uses the data contained in the Election Manifest to associate ballots with specific ballot styles and to verify the accuracy of data at different stages of the election process. Note that not all of the data contained in the Election Manifest impacts the computations of tallies and zero-knowledge proofs used in the published election data that demonstrates end-to-end verifiability; however it is important to include as much data as possible in order to distinguish one election from another. With a well-defined Election Manifest, improperly formatted ballot encryption requests will fail with error messages at the moment of initial encryption; the enforcement of any logic or behavior to prevent overvoting or other malformed ballot submissions are handled by the encrypting device, not ElectionGuard. In addition, since json files do not accommodate comments, all notations and exceptions are documented in this readme. Election Data Structure Elections are characterized into types by NIST as shown in the table below election type description general For an election held typically on the national day for elections. partisan-primary-closed For a primary election that is for a specific party where voter eligibility is based on registration. partisan-primary-open For a primary election that is for a specific party where voter declares desired party or chooses in private. primary For a primary election without a specified type, such as a nonpartisan primary. runoff For an election to decide a prior contest that ended with no candidate receiving a majority of the votes. special For an election held out of sequence for special circumstances, for example, to fill a vacated office. other Used when the election type is not listed in this enumeration. If used, include a specific value of the OtherType element. We present two sample manifests: general and partisan-primary-closed . The core distinction between the two samples is the role of party: in general elections voters can choose to vote for candidates from any party in a contest, regardless of party affiliation. In partisan primaries voters can only vote in contests germane to their party declaration or affiliation. As such, special , runoff , and primary election types will follow the general pattern, and partisan-primary-open will follow the partisan-primary-closed pattern. Open primary elections can follow either pattern as determined by their governing rules and regulations. (As noted above, ElectionGuard expects properly-formed ballots; e.g., it would error and fail to encrypt a ballot in an open-primary-closed election if a contest with an incorrect party affiliation were submitted (as indicated by the ).) Ballot Styles and Geography At least in the United States, many complications are introduced by voting simultaneously on election contests that apply in specific geographies and jurisdictions. For example, a single election could include contests for congress, state assembly, school, and utility districts, each with their own geographic boundaries, many that do not respect town or county lines. The ElectionGuard Election Manifest data format is flexible to accommodate most situations, but it is usually up to the election commission and the external system to determine what each component of the manifest actually means. In the following examples, we will work through the process of defining different election types at a high level and describe the process of building the election manifest. Geographic and Ballot Style Breakdown Each election can be thought of as a list of contests that are relevant to a certain group of people in a specific place. In order to determine who is supposed to vote on which contests, we first need to define the geographic jurisdictions where the election is taking place. The NIST Guidelines present an excellent discussion of the geographic interplay of different contests. The diagram from page 12 is presented below. As the diagram shows, congressional, state assembly, school district and other geographic boundaries project onto towns and municipalities in different ways. Elections manage this complexity by creating unique ballot styles that present to voters only the contests that pertain to them. Different jurisdictions use terms such as wards, precincts, and districts to describe the areas of overlap that guide ballot style creation. We will use precinct but ward and district could be used instead. Contests, Candidates and Parties In most cases, a resident of a specific precinct or location will expect to see a certain list of contests that are relevant to them. A contest is a specific collection of available choices ( selections ) from which the voter may choose some subset. For the ElectionGuard Election Manifest, each possible selection in a contest must be associated with a candidate, even for Referendum-style contests. If a contest also supports write-in values, then a write-in candidate is also defined. Candidates may also be associated with specific parties, but this is not required for all election types. Introducing Hamilton County, OZ To help disambiguate, let's explore an example. Geographic Jurisdictions Hamilton County includes 3 townships: LaCroix, Arlington, Harris. The town of LaCroix also has a utility district that comprises its own precinct for special referendums. Arlington has two distinct school districts. The county is also split into two congressional districts, district 5 and district 7. Harris township is entirely within Congressional District 5, but both LaCroix and Arlington are split between congressional districts 5 and 7. Building the Geographic Jurisdiction Mapping (Geopolitical Units) The Election Manifest includes an array of objects called geopoliticalUnits (a.k.a. gpUnit ). Each Geopolitical Unit must include the following fields: - objectId - a unique identifier for the gpUnit. This value is used to map a contest to a specific jurisdiction - name - the friendly name of the gp Unit - type - they type of jurisdiction (one of the Reporting Unit Types ) - contact information - the contact info for the geopolitical unit Geopolitical units are polygons on a map represented by legal jurisdictions. In our example Election Manifest for hamilton County, there is one geopolitical unit for each jurisdictional boundary in the image above: - Hamilton County - Congressional District 5 - congressional District 7 - LaCroix Township - Exeter Utility District (within LaCroix Township) - Harris Township - Arlington Township - Pismo Beach School District (within Arlington Township) - Somerset School District (within Arlington Township) When defining the geopolitical units for an election, we define all of the possible geopolitical units for an election; even if there are no contests for a specific jurisdiction. This way, if contests are added or removed during the setup phase, you do not also have to remember to update the list of geopolitical units. Alternatively, you can define only the GP Units for which there are contests. The General Election Contests A general election will occur in Hamilton County. The county is voting along with the rest of the province, and the county is responsible for tabulating its own election results. This means that the Election Scope is defined at the county level. For the general election, the following sets of contests (and associated geographic boundaries) obtain: The National Contests - President and Vice President. This contest demonstrates a \"vote for the ticket\" and allows write-ins Province Contests - Governor - this contest demonstrates a long list of candidate names Congressional Contests - Congress Districts 5 and 7 - these contests demonstrate how to split a district using multiple ballot styles Township Contests - Retain Chief Justice - This contest demonstrates a contest that applies to a specific town whose boundaries are split across multiple ballot styles School District Contests - School Board - these contests demonstrate contests with multiple selections ( n-of-m ) and allow write-ins School Board, and Utility district referendum to show ballot style splits Utility District Contest - Utility District - This contest demonstrates a referendum-style contest with long descriptions and display language translation into Spanish Each contest must be associated with exactly ONE electoralDistrictId . The electoralDistrictId field on the contest is populated with the objectId of the associated Geopolitical Unit (e.g. the Contest congress-district-7-contest has the electoralDistrictId congress-district-7 Each contest must also define a sequenceOrder . the sequence order is an indexing mechanism used internally. It is not the sequence that the contests are displayed to the user . The order in which contests are displayed to the user is up to the implementing application. The General Election Ballot Styles A ballot style is the set of contests that a specific voter should see on their ballot for a given location. The ballot style is associated to the set of geopolitical units relevant to a specific point on a map. Since each contest is also associated with a geopolitical unit, a mapping is created between a point on a map and the contests that are relevant to that point. For instance, a voter that lives in the Exeter Utility District should see contests that are relevant to Congressional District 7, LaCroix Township and the Exeter Utility District. | Geopolitical Units are overlapping polygons, and ballot styles are the list of polygons relevant to a specific point on the map. Similar to Geopolitical Units, we define all of the possible ballot styles for an election in our example, even if there are no contests specific to a ballot style. This is subjective and the behavior may be different for the integrating system: - Congressional District 7 Outside Any Township - Congressional District 7 LaCroix Township - Congressional District 7 LaCroix Township Exeter Utility District - Congressional District 7 Arlington Township - Congressional District 7 Arlington Township Pismo Beach School district - Congressional District 7 Arlington Township Somerset School district - Congressional District 5 Outside Any Township - Congressional District 5 LaCroix Township - Congressional District 5 Harris Township - Congressional District 5 Arlington Township Pismo Beach School district - Congressional District 5 Arlington Township Somerset School district By defining all of the possible ballot styles and all of the possible geopolitical units, we ensure that if a contest is added or removed, we only have to make sure the contest is correct. We do not have to modify the list of geopolitical units or ballot styles. Data Flexibility The relationship between a ballot style and the contests that are displayed on it are subjective to the implementing application. This example is just one way to define this relationship that is purposefully verbose. For instance, in our example we define a geopolitical unit as a set of overlapping polygons, and a ballot style as the intersection of those polygons at a specific point. This is a top-down approach. Alternatively, we could have defined a geopolitical unit as the intersection area of those polygons and mapped one ballot style to each geopolitical unit 1 to 1. for instance, instead of defining a single GP Unit each for: - Congressional District 5, - Congressional District 7, - LaCroix Township, - Exeter Utility district, etc; we could have instead defined the GP Units as: - Congressional District 5 No Township - Congressional District 7 No Township - Congressional District 5 inside LaCroix - Congressional District 5 Inside LaCroix and Exeter, etc. Then, instead of each Ballot Style having multiple GP Units, each ballot style would have applied to exactly one GP Unit. Data Validation When the election Manifest is loaded into ElectionGuard, its validity is checked semantically against the data format required to conduct an ElectionGuard Election. Specifically, we check that: - Each Geopolitical Unit has a unique objectId - Each Ballot Style maps to at least one valid Geopolitical Unit - Each Party has a unique objectId - Each Candidate either does not have a party, or is associated with a valid party - Each Contest has a unique Sequence Order - Each contest is associated with exactly one valid geopolitical unit - Each contest has a valid number of selections for the number of seats in the contest - Each selection on each contest is associated with a valid Candidate as long as the election manifest format matches the validation criteria, the election can proceed as an ElectionGuard election. Frequently Asked Questions Q: What if my ballot styles are not associated with geopolitical units? A: There are a few ways to handle this. In most cases, you can simply map the ballot style 1 to 1 to the geopolitical unit. for instance, if ballot-style-1 includes contest-1 then you may create geopolitical-unit-1 and associate both the ballot style and the contest to that geopolitical unit. This documentation is under review and subject to change. Please do not hesitate to open a github issue if you have questions, or find errors or omissions.","title":"Election Manifest"},{"location":"Election_Manifest/#overview","text":"There are many types of elections. We need a base set of data that shows how these different types of elections are handled in an ElectionGuard end-to-end verifiable election (or ballot comparison audits). We worked with InfernoRed, VotingWorks, and Dan Wallach of Rice University (thanks folks!) to develop a set of conventions, tests, and sample data (based on a starting dataset sample from the Center for Civic Design) that demonstrate how to encode the information necessary to conduct an election into a format that ElectionGuard can use. The election terms and structure are based whenever possible on the NIST SP-1500-101 Election Event Logging Common Data Format Specification (with a prettier and (mostly) more functional implementation here and a PDF for version 2 ). The information captured by the NIST standard is codified into an election manifest that defines common elements when conducting an election, such as locations, candidates, parties, contests, and ballot styles. ElectionGuard uses the data contained in the Election Manifest to associate ballots with specific ballot styles and to verify the accuracy of data at different stages of the election process. Note that not all of the data contained in the Election Manifest impacts the computations of tallies and zero-knowledge proofs used in the published election data that demonstrates end-to-end verifiability; however it is important to include as much data as possible in order to distinguish one election from another. With a well-defined Election Manifest, improperly formatted ballot encryption requests will fail with error messages at the moment of initial encryption; the enforcement of any logic or behavior to prevent overvoting or other malformed ballot submissions are handled by the encrypting device, not ElectionGuard. In addition, since json files do not accommodate comments, all notations and exceptions are documented in this readme.","title":"Overview"},{"location":"Election_Manifest/#election-data-structure","text":"Elections are characterized into types by NIST as shown in the table below election type description general For an election held typically on the national day for elections. partisan-primary-closed For a primary election that is for a specific party where voter eligibility is based on registration. partisan-primary-open For a primary election that is for a specific party where voter declares desired party or chooses in private. primary For a primary election without a specified type, such as a nonpartisan primary. runoff For an election to decide a prior contest that ended with no candidate receiving a majority of the votes. special For an election held out of sequence for special circumstances, for example, to fill a vacated office. other Used when the election type is not listed in this enumeration. If used, include a specific value of the OtherType element. We present two sample manifests: general and partisan-primary-closed . The core distinction between the two samples is the role of party: in general elections voters can choose to vote for candidates from any party in a contest, regardless of party affiliation. In partisan primaries voters can only vote in contests germane to their party declaration or affiliation. As such, special , runoff , and primary election types will follow the general pattern, and partisan-primary-open will follow the partisan-primary-closed pattern. Open primary elections can follow either pattern as determined by their governing rules and regulations. (As noted above, ElectionGuard expects properly-formed ballots; e.g., it would error and fail to encrypt a ballot in an open-primary-closed election if a contest with an incorrect party affiliation were submitted (as indicated by the ).)","title":"Election Data Structure"},{"location":"Election_Manifest/#ballot-styles-and-geography","text":"At least in the United States, many complications are introduced by voting simultaneously on election contests that apply in specific geographies and jurisdictions. For example, a single election could include contests for congress, state assembly, school, and utility districts, each with their own geographic boundaries, many that do not respect town or county lines. The ElectionGuard Election Manifest data format is flexible to accommodate most situations, but it is usually up to the election commission and the external system to determine what each component of the manifest actually means. In the following examples, we will work through the process of defining different election types at a high level and describe the process of building the election manifest.","title":"Ballot Styles and Geography"},{"location":"Election_Manifest/#geographic-and-ballot-style-breakdown","text":"Each election can be thought of as a list of contests that are relevant to a certain group of people in a specific place. In order to determine who is supposed to vote on which contests, we first need to define the geographic jurisdictions where the election is taking place. The NIST Guidelines present an excellent discussion of the geographic interplay of different contests. The diagram from page 12 is presented below. As the diagram shows, congressional, state assembly, school district and other geographic boundaries project onto towns and municipalities in different ways. Elections manage this complexity by creating unique ballot styles that present to voters only the contests that pertain to them. Different jurisdictions use terms such as wards, precincts, and districts to describe the areas of overlap that guide ballot style creation. We will use precinct but ward and district could be used instead.","title":"Geographic and Ballot Style Breakdown"},{"location":"Election_Manifest/#contests-candidates-and-parties","text":"In most cases, a resident of a specific precinct or location will expect to see a certain list of contests that are relevant to them. A contest is a specific collection of available choices ( selections ) from which the voter may choose some subset. For the ElectionGuard Election Manifest, each possible selection in a contest must be associated with a candidate, even for Referendum-style contests. If a contest also supports write-in values, then a write-in candidate is also defined. Candidates may also be associated with specific parties, but this is not required for all election types.","title":"Contests, Candidates and Parties"},{"location":"Election_Manifest/#introducing-hamilton-county-oz","text":"To help disambiguate, let's explore an example.","title":"Introducing Hamilton County, OZ"},{"location":"Election_Manifest/#geographic-jurisdictions","text":"Hamilton County includes 3 townships: LaCroix, Arlington, Harris. The town of LaCroix also has a utility district that comprises its own precinct for special referendums. Arlington has two distinct school districts. The county is also split into two congressional districts, district 5 and district 7. Harris township is entirely within Congressional District 5, but both LaCroix and Arlington are split between congressional districts 5 and 7.","title":"Geographic Jurisdictions"},{"location":"Election_Manifest/#building-the-geographic-jurisdiction-mapping-geopolitical-units","text":"The Election Manifest includes an array of objects called geopoliticalUnits (a.k.a. gpUnit ). Each Geopolitical Unit must include the following fields: - objectId - a unique identifier for the gpUnit. This value is used to map a contest to a specific jurisdiction - name - the friendly name of the gp Unit - type - they type of jurisdiction (one of the Reporting Unit Types ) - contact information - the contact info for the geopolitical unit Geopolitical units are polygons on a map represented by legal jurisdictions. In our example Election Manifest for hamilton County, there is one geopolitical unit for each jurisdictional boundary in the image above: - Hamilton County - Congressional District 5 - congressional District 7 - LaCroix Township - Exeter Utility District (within LaCroix Township) - Harris Township - Arlington Township - Pismo Beach School District (within Arlington Township) - Somerset School District (within Arlington Township) When defining the geopolitical units for an election, we define all of the possible geopolitical units for an election; even if there are no contests for a specific jurisdiction. This way, if contests are added or removed during the setup phase, you do not also have to remember to update the list of geopolitical units. Alternatively, you can define only the GP Units for which there are contests.","title":"Building the Geographic Jurisdiction Mapping (Geopolitical Units)"},{"location":"Election_Manifest/#the-general-election-contests","text":"A general election will occur in Hamilton County. The county is voting along with the rest of the province, and the county is responsible for tabulating its own election results. This means that the Election Scope is defined at the county level. For the general election, the following sets of contests (and associated geographic boundaries) obtain: The National Contests - President and Vice President. This contest demonstrates a \"vote for the ticket\" and allows write-ins Province Contests - Governor - this contest demonstrates a long list of candidate names Congressional Contests - Congress Districts 5 and 7 - these contests demonstrate how to split a district using multiple ballot styles Township Contests - Retain Chief Justice - This contest demonstrates a contest that applies to a specific town whose boundaries are split across multiple ballot styles School District Contests - School Board - these contests demonstrate contests with multiple selections ( n-of-m ) and allow write-ins School Board, and Utility district referendum to show ballot style splits Utility District Contest - Utility District - This contest demonstrates a referendum-style contest with long descriptions and display language translation into Spanish Each contest must be associated with exactly ONE electoralDistrictId . The electoralDistrictId field on the contest is populated with the objectId of the associated Geopolitical Unit (e.g. the Contest congress-district-7-contest has the electoralDistrictId congress-district-7 Each contest must also define a sequenceOrder . the sequence order is an indexing mechanism used internally. It is not the sequence that the contests are displayed to the user . The order in which contests are displayed to the user is up to the implementing application.","title":"The General Election Contests"},{"location":"Election_Manifest/#the-general-election-ballot-styles","text":"A ballot style is the set of contests that a specific voter should see on their ballot for a given location. The ballot style is associated to the set of geopolitical units relevant to a specific point on a map. Since each contest is also associated with a geopolitical unit, a mapping is created between a point on a map and the contests that are relevant to that point. For instance, a voter that lives in the Exeter Utility District should see contests that are relevant to Congressional District 7, LaCroix Township and the Exeter Utility District. | Geopolitical Units are overlapping polygons, and ballot styles are the list of polygons relevant to a specific point on the map. Similar to Geopolitical Units, we define all of the possible ballot styles for an election in our example, even if there are no contests specific to a ballot style. This is subjective and the behavior may be different for the integrating system: - Congressional District 7 Outside Any Township - Congressional District 7 LaCroix Township - Congressional District 7 LaCroix Township Exeter Utility District - Congressional District 7 Arlington Township - Congressional District 7 Arlington Township Pismo Beach School district - Congressional District 7 Arlington Township Somerset School district - Congressional District 5 Outside Any Township - Congressional District 5 LaCroix Township - Congressional District 5 Harris Township - Congressional District 5 Arlington Township Pismo Beach School district - Congressional District 5 Arlington Township Somerset School district By defining all of the possible ballot styles and all of the possible geopolitical units, we ensure that if a contest is added or removed, we only have to make sure the contest is correct. We do not have to modify the list of geopolitical units or ballot styles.","title":"The General Election Ballot Styles"},{"location":"Election_Manifest/#data-flexibility","text":"The relationship between a ballot style and the contests that are displayed on it are subjective to the implementing application. This example is just one way to define this relationship that is purposefully verbose. For instance, in our example we define a geopolitical unit as a set of overlapping polygons, and a ballot style as the intersection of those polygons at a specific point. This is a top-down approach. Alternatively, we could have defined a geopolitical unit as the intersection area of those polygons and mapped one ballot style to each geopolitical unit 1 to 1. for instance, instead of defining a single GP Unit each for: - Congressional District 5, - Congressional District 7, - LaCroix Township, - Exeter Utility district, etc; we could have instead defined the GP Units as: - Congressional District 5 No Township - Congressional District 7 No Township - Congressional District 5 inside LaCroix - Congressional District 5 Inside LaCroix and Exeter, etc. Then, instead of each Ballot Style having multiple GP Units, each ballot style would have applied to exactly one GP Unit.","title":"Data Flexibility"},{"location":"Election_Manifest/#data-validation","text":"When the election Manifest is loaded into ElectionGuard, its validity is checked semantically against the data format required to conduct an ElectionGuard Election. Specifically, we check that: - Each Geopolitical Unit has a unique objectId - Each Ballot Style maps to at least one valid Geopolitical Unit - Each Party has a unique objectId - Each Candidate either does not have a party, or is associated with a valid party - Each Contest has a unique Sequence Order - Each contest is associated with exactly one valid geopolitical unit - Each contest has a valid number of selections for the number of seats in the contest - Each selection on each contest is associated with a valid Candidate as long as the election manifest format matches the validation criteria, the election can proceed as an ElectionGuard election.","title":"Data Validation"},{"location":"Election_Manifest/#frequently-asked-questions","text":"Q: What if my ballot styles are not associated with geopolitical units? A: There are a few ways to handle this. In most cases, you can simply map the ballot style 1 to 1 to the geopolitical unit. for instance, if ballot-style-1 includes contest-1 then you may create geopolitical-unit-1 and associate both the ballot style and the contest to that geopolitical unit. This documentation is under review and subject to change. Please do not hesitate to open a github issue if you have questions, or find errors or omissions.","title":"Frequently Asked Questions"},{"location":"Project_Workflow/","text":"Project Workflow \u2728 Start an Iteration Each iteration on this repository will be tracked by a GitHub Milestone . The completion of the milestone will queue a GitHub Release . Issues will be added to the milestones to indicate work needed. After completion, this milestone can then act as a list of work contained within a release. \ud83d\udd00 Pull Request Attach Issue Each pull request MUST be attached to an issue. On the surface, this ensures that closing a pull request will close an issue. This also ensures the issue can be included in the milestone. For this repository, the use of issues assists the team to use the project board to track the progress towards a milestone. Validation Each pull request is validated by the Pull Request Validation GitHub Action . This action can be viewed from the PR or from the actions to inspect the details. Review All pull requests require a review from a Contributor but any reviewers are welcome. \ud83c\udfc1 Create a Release At the end of an iteration aka when a milestone is complete, a release can be created. Steps Raise version number in setup.py Close Milestone Edit Release details (optional) Release Workflow Closing the milestone queues the Release Build GitHub Action . This action is designed to reduce the effort by maintainers and give the community an open view of the package flow. Build package Create dependency graph Upload package to PyPi Validate PyPi package Upload package and graph to GitHub Workflow Create Release Upload zipped package and graph to Release Update GitHub Pages Documentation","title":"Project Workflow"},{"location":"Project_Workflow/#project-workflow","text":"","title":"Project Workflow"},{"location":"Project_Workflow/#start-an-iteration","text":"Each iteration on this repository will be tracked by a GitHub Milestone . The completion of the milestone will queue a GitHub Release . Issues will be added to the milestones to indicate work needed. After completion, this milestone can then act as a list of work contained within a release.","title":"\u2728 Start an Iteration"},{"location":"Project_Workflow/#pull-request","text":"","title":"\ud83d\udd00 Pull Request"},{"location":"Project_Workflow/#attach-issue","text":"Each pull request MUST be attached to an issue. On the surface, this ensures that closing a pull request will close an issue. This also ensures the issue can be included in the milestone. For this repository, the use of issues assists the team to use the project board to track the progress towards a milestone.","title":"Attach Issue"},{"location":"Project_Workflow/#validation","text":"Each pull request is validated by the Pull Request Validation GitHub Action . This action can be viewed from the PR or from the actions to inspect the details.","title":"Validation"},{"location":"Project_Workflow/#review","text":"All pull requests require a review from a Contributor but any reviewers are welcome.","title":"Review"},{"location":"Project_Workflow/#create-a-release","text":"At the end of an iteration aka when a milestone is complete, a release can be created.","title":"\ud83c\udfc1 Create a Release"},{"location":"Project_Workflow/#steps","text":"Raise version number in setup.py Close Milestone Edit Release details (optional)","title":"Steps"},{"location":"Project_Workflow/#release-workflow","text":"Closing the milestone queues the Release Build GitHub Action . This action is designed to reduce the effort by maintainers and give the community an open view of the package flow. Build package Create dependency graph Upload package to PyPi Validate PyPi package Upload package and graph to GitHub Workflow Create Release Upload zipped package and graph to Release Update GitHub Pages Documentation","title":"Release Workflow"}]}